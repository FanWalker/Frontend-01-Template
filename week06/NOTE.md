## 有限状态机处理字符串
每一个状态都是一个机器，每个机器可以做计算、存储、输出...；所有的机器接受的输入都是一致的；每个机器本身没有状态，用函数表示的话，应该是纯函数

每一个机器都知道下一个状态：每个机器都有确定的下一个状态（Moore）；每个机器根据输入决定下一个状态（Mealy）

使用状态机（Mealy）

	// 每个函数是一个状态
	function state(input) // 函数参数就是输入
	{
		// 在函数中，可以自由地编写代码，处理每个状态的逻辑
		return next; // 返回值作为下一个状态
	}

	// 以下是调用
	while(input) {
		// 获取输入
		state = state(input); // 把状态机的返回值作为下一个状态
	}

#### 解析body

第一步：拆分文件

把parser单独拆到文件中；parser接受html文本作为参数，返回一颗DOM树

第二步： 创建状态机

用有限状态机来实现HTML的分析；在HTML标准中已经规定HTML的状态；Toy-Browser只选择一部分状态完成一个最简版本

第三步：解析标签 

主要标签有： 开始标签、结束标签和自封闭标签，这一步暂时忽略属性

第四步：创建元素

除了状态迁移，还要加入业务逻辑，在标签结束状态提交标签token

第五步：处理属性

属性分为单引号、双引号、无引号三种写法，需要较多状态处理；处理属性的方式跟标签类似；属性结束时，把属性加到标签token上

第六步：构建DOM树

从标签构建DOM树使用栈；遇到开始标签时创建元素并入栈，遇到结束标签时出栈；自封闭节点可视为入栈后立刻出栈；任何元素的父元素
是它入栈前的栈顶

第七步：处理文本节点


#### 解析css

第一步：收集css

遇到style标签时，把css规则保存起来；调用css parser分析css规则；要仔细研究此库是怎么样分析css规则格式的

第二部：添加调用

创建一个元素后，立即计算css；理论上，当我们分析一个元素时，所有css规则已经收集完毕；真实浏览器中，可能遇到body的style标签，css需要
重新计算，这里忽略，重排必会重绘

第三步：获取父元素序列

在computeCSS函数中，必须要知道当前元素的所有父元素才能判断元素与规则是否匹配；我们从上一步步骤的stack，可以获取本元素的所有父元素；
因为我们首先获取的是‘当前元素’，所以我们获取和计算父元素匹配的顺序是从内向外

第四步：拆分选择器

选择器也要从当前元素向外排列；复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列


第五步：计算选择器与元素匹配

根据选择器的类型和元素属性，计算是否与当前元素匹配；这里只实现了三种基本选择器，实际的浏览器中要处理复合选择器

第六步：生成computed属性加入到element

一旦选择匹配，就应用选择器到元素上，形成computedStyle

第七步：确定覆盖规则关系

CSS规则根据specificity和后来优先规则覆盖；specificity是个四元组，越左边权重越高；一个CSS规则的specificity根据包含的简单选择器相加而成


	body div a.x#y {
		color: red;
	}
	specificity：[0, 1, 1, 3] 最左边的代表的是inline样式个数，第二个是id选择器，第三个是class选择器，第四个是标签选择器